{"title":"A Message queue in Racket - part 2","date":"2021-10-22T14:26:28.000Z","date_formatted":{"ll":"Oct 22, 2021","L":"10/22/2021","MM-DD":"10-22"},"link":"2021/10/22/A-message-queue-racket-part-2","tags":["Racket"],"categories":["Programming","message queue"],"updated":"2022-01-26T02:24:54.563Z","content":"<p>This post is the second in a series describing the creation of a message queue</p>\n<span id=\"more\"></span>\n<h1 id=\"table-of-contents:\">Table of Contents:<a title=\"#table-of-contents:\" href=\"#table-of-contents:\"></a></h1>\n<ul>\n<li>Introducing the server shell</li>\n<li>The middle layer</li>\n<li>Testing what we have</li>\n</ul>\n<h1 id=\"introduction\">Introduction<a title=\"#introduction\" href=\"#introduction\"></a></h1>\n<p>This is the 2nd post in this series. We are exploring building a message queue using Racket. The message queue is a program that provides an API to store and retrieve messages. It organizes messages on topics and each topic has a queue associated with it.</p>\n<p>We are using Racket’s web stack to provide the web interface, a Racket hash-table to provide the topics and a Racket data/queue to provide the queues for storing messages. Racket provides a nice JSON library for handling JSON.</p>\n<p>In the first installment of this <a href=\"https://muguira-james.github.io/2021/10/13/A-message-Queue-in-Racket/\" target=\"_blank\">series</a>, we described the scaffolding for the application. The application at this point exposes an API with 1 method in it: ‘hello’, which just provides a string with the date and time embedded when you call it. We will define more data structures and 1 more API call in this article.</p>\n<p>So far, our backend architecture defines a front door and a middle layer. The front door code hides the web mechanics of handling http requests. It dispatches to our simple ‘hello’ API method. Let’s extend that to expose the dispatching. Once we have the dispatch code exposed, we can further extend to add the various API calls that finish off the application. The last line of the application called the web server start up code and established the ports, URLs and other items needed to make our sever. Our extensions follow:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#lang racket</span><br><span class=\"line\"></span><br><span class=\"line\">(require web-server/servlet) </span><br><span class=\"line\">(require web-server/servlet-env)</span><br><span class=\"line\">(require json)</span><br><span class=\"line\">(require data/queue)</span><br><span class=\"line\"></span><br><span class=\"line\">(require gregor)</span><br><span class=\"line\"></span><br><span class=\"line\">(define (hello request)</span><br><span class=\"line\">  (http-response  &quot;Hello from message queue&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">(define (http-response content)</span><br><span class=\"line\">  (response/full</span><br><span class=\"line\">    200                  ; HTTP response code.</span><br><span class=\"line\">    #&quot;OK&quot;                ; HTTP response message.</span><br><span class=\"line\">    (current-seconds)    ; Timestamp.</span><br><span class=\"line\">    TEXT/HTML-MIME-TYPE  ; MIME type for content.</span><br><span class=\"line\">    &#x27;()                  ; Additional HTTP headers.</span><br><span class=\"line\">    (list                ; Content (in bytes) to send to the browser.</span><br><span class=\"line\">      (string-&gt;bytes/utf-8 content))))</span><br><span class=\"line\"></span><br><span class=\"line\">(define-values (dispatch generate-url)</span><br><span class=\"line\">  ;; URL routing table (URL dispatcher).</span><br><span class=\"line\">  (dispatch-rules</span><br><span class=\"line\">   [(&quot;&quot;) do-nothing]</span><br><span class=\"line\">   [(&quot;hello&quot;) greeting-page]  ; check to see if the service is working</span><br><span class=\"line\">   [(&quot;enque&quot;) #:method &quot;post&quot; enque]</span><br><span class=\"line\">  ;  [(&quot;deque&quot;) #:method &quot;post&quot; deque]</span><br><span class=\"line\">   [(&quot;topic-list&quot;) topic-list]</span><br><span class=\"line\"> ;  [(&quot;topic-count&quot;) topic-count]</span><br><span class=\"line\"> ;   [(&quot;topic-data&quot;) #:method &quot;post&quot; topic-data]</span><br><span class=\"line\"> ;  [(&quot;drain-topic&quot;) #:method &quot;post&quot; drain-topic]</span><br><span class=\"line\"> ;  [(&quot;drain-queue&quot;) #:method &quot;post&quot; drain-queue]</span><br><span class=\"line\">   [else (error &quot;page not found&quot;)]))</span><br><span class=\"line\"></span><br><span class=\"line\">(define (request-handler request)</span><br><span class=\"line\">  (dispatch request))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">;; Start the server.</span><br><span class=\"line\">(serve/servlet</span><br><span class=\"line\">  request-handler</span><br><span class=\"line\">  #:launch-browser? #f</span><br><span class=\"line\">  #:quit? #f</span><br><span class=\"line\">  ; have to listen on the  right host NOT 127.0.0.1</span><br><span class=\"line\">  #:listen-ip &quot;0.0.0.0&quot;</span><br><span class=\"line\">  #:port 8000</span><br><span class=\"line\">  #:servlet-regexp #rx&quot;&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>There are now 4 methods (in reverse order): server/servlet, request-handler, define-values, and http-response. Http-response has not changed. It is our common code we defined to reply to a request from a caller.  It takes a string as input and create a http response suitable for a caller to process with either text (TEXT/HTML-MIME-TYPE) or JSON.  To REALLY do JSON we should change the “TEXT/HTML-MIME-TYPE” string to “APPLICATION/JSON”, but we’ll leave that for now.</p>\n<p>The next function, define-values is a Racket construct that binds variables as the language parser is working its way through code file. It builds a look up table.  It works like a let statement in that variable definitions are created as the reader is parsing your Racket expressions. Racket uses a 2-step process to translate Racket expressions into working code: a reader and an expansion processor. The define-values creates and binds values to the variables during the reader process. In our case, for each item found on the input URL, the dispatcher will look for a definition. The only valid URL expansions are:</p>\n<ul>\n<li>“”, which corresponds to <a href=\"http://localhost:8000/\">http://localhost:8000/</a>,</li>\n<li>“hello”, which would call the hello function,</li>\n<li>“enque”, which would call the enqueue function,</li>\n<li>“deque”, which would call the dequeue function,</li>\n<li>“topic-list”, which calls topic-list function,</li>\n<li>“topic-count”, which calls the topic-count function,</li>\n<li>“topic-data”, which calls the topic-data function,</li>\n<li>“drain-topic”, calling the topic drain function,</li>\n<li>“drain-que”, calling the drain queue function.</li>\n</ul>\n<p>If the item decoded from the URL does equal one of those handlers, the dispatcher will call the error handler. The next function is the actual request-handler. The Racket web application framework we are working with will parse the in-coming URL and break it down into components.  By the time the server is ready to call request-handler, which you notice is the 1st parameter to the server/servlet, the URL is parsed, and the API is ready to decode and route to the correct call.  For example, if we were to use curl, a well-formed URL would look like:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl --data &quot;&#123; &quot;param1&quot;: &quot;value1&quot;, &quot;param2&quot;: &quot;value2&quot;  http://hostname/resource</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"middle-layer\">Middle Layer<a title=\"#middle-layer\" href=\"#middle-layer\"></a></h1>\n<p>The previous section just described the entire front door of our message queue. The next sections describe the middle layer. Here we will introduce the logic for each API call and describe how to test the code.</p>\n<p>The first function we introduce is enqueue.  The basic message storage mechanism for the program is a topic hash, which is a hash table where the keys are the topic names and each name has a value element that is a Racket data/queue. This function adds a message payload element into the queue associated with the topic.  This topic structure can be visualized like so:</p>\n<p><img src=\"/images/Racket-queue-2.png\" alt=\"topic-hash structure\" loading=\"lazy\" class=\"φbp\"></p>\n<p>The enqueue function in our message queue system has 2 elements: the dispatch target in the front door and a function for handling the message data structure. Let’s take a look at the front door element:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;; a hash is structured as a topic and a queue</span><br><span class=\"line\">(define topic-hash (make-hash))</span><br><span class=\"line\"></span><br><span class=\"line\">(define (enque request)</span><br><span class=\"line\">  ; put something in a queue</span><br><span class=\"line\">  ; input: &#123; topic: &quot;name&quot;, payload: &quot;data-type&quot; &#125;</span><br><span class=\"line\">  (let* ([hsh (request-&gt;jshash request)]</span><br><span class=\"line\">         [topic-name (hash-ref hsh &#x27;topicname)]</span><br><span class=\"line\">         [payload-data (hash-ref hsh &#x27;payload)])</span><br><span class=\"line\">    (begin         </span><br><span class=\"line\">      (add-data-to-topic topic-name payload-data)</span><br><span class=\"line\">      (displayln</span><br><span class=\"line\">       (format</span><br><span class=\"line\">        &quot;enq: name: ~v: data: ~v hash-size: ~v hash-keys: ~v~%&quot;</span><br><span class=\"line\">        topic-name payload-data (hash-count topic-hash) (hash-keys topic-hash)))</span><br><span class=\"line\">      (let ([rtn (make-hash)])</span><br><span class=\"line\">        (hash-set! rtn &#x27;topic-name topic-name)</span><br><span class=\"line\">        (hash-set! rtn &#x27;data payload-data)</span><br><span class=\"line\">        (hash-set! rtn &#x27;count (hash-count topic-hash))</span><br><span class=\"line\">        (hash-set! rtn &#x27;keys (hash-keys topic-hash))</span><br><span class=\"line\">        (displayln (with-output-to-string (lambda () (write-json  rtn))))</span><br><span class=\"line\">        (http-response (with-output-to-string (lambda  () (write-json rtn))))))))</span><br></pre></td></tr></table></figure>\n<p>While it looks complex, that is because it handles getting the topic name and payload from the input http message. It then calls the code that handles the internal data structures.  Finally, it builds the output response to send back to the client.  The response is most of the code. The response creates a hash, which is converted to JSON and written to the client.  The response hash fields: “topic-name”, “data”, “count” and the “key” value all encoded.</p>\n<p>The enqueue function takes a topic name and a message payload element as input. Its operation is simple: if the topic-name is present, add the message data to the queue and return.  If not present, create a new queue, add the message data to that queue and add that queue to the input topic-name, then return.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(define (add-data-to-topic key data)</span><br><span class=\"line\">  ;; check to see if key is in the topic-hash and add data to the correct topic</span><br><span class=\"line\">  (if (contains-topic key)</span><br><span class=\"line\">      (enqueue! (hash-ref topic-hash key) data)</span><br><span class=\"line\">      (begin</span><br><span class=\"line\">        (let ([q (make-queue)])</span><br><span class=\"line\">          (enqueue! q data)</span><br><span class=\"line\">          (hash-set! topic-hash key q)))))</span><br></pre></td></tr></table></figure>\n<h1 id=\"testing-what-we-have\">Testing what we have<a title=\"#testing-what-we-have\" href=\"#testing-what-we-have\"></a></h1>\n<p>Let’s test the program. To do so, use the racket program interpreter to run the front-door.rkt file. This will produce some messages. Now, in another terminal, let’s run the test code “enq.js” which will try and add a topic and payload to the message queue system. The output looks like:</p>\n<p>In the racket terminal:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ racket  front-door.rkt</span><br><span class=\"line\">Your Web application is running at http://localhost:8000.</span><br><span class=\"line\">Stop this program at any time to terminate the Web Server.</span><br><span class=\"line\">enq: name: &quot;a-topic&quot;: data: &quot;(&quot;brownies and ice cream&quot;) hash-size:  1 hash-keys: &quot;(&quot;a-topic&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;count&quot;: 1, &quot;data&quot;: [&quot;brownies and ice cream&quot;], &quot;keys&quot;: [&quot;a-topic&quot;], &quot;topic-name&quot;:  &quot;a-topic&quot; &#125;</span><br></pre></td></tr></table></figure>\n<p>In the node code terminal:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node enq.js -q a-topic -p &quot;brownies and ice cream&quot;</span><br><span class=\"line\">Options-&gt; &#123; que_name: &quot;a-topic&quot;,  payload: &quot;brownies and ice cream&quot; &#125;</span><br><span class=\"line\">Sending... &#123; que_name: &quot;a-topic&quot;,  payload: &quot;brownies and ice cream&quot; &#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">count: 1,</span><br><span class=\"line\">data: &quot;brownies and ice cream&quot;,</span><br><span class=\"line\">keys: [ &quot;a-topic&quot; ],</span><br><span class=\"line\">topic-name: &quot;a-topic&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Quite a lot of output from each window, but you can see how the racket front-door program used “display” to send data to the console.</p>\n<p>This is the node program enq.js:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">const fetch = require(&#x27;node-fetch&#x27;)</span><br><span class=\"line\">const commandlineargs = require(&#x27;command-line-args&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const optionDefinitions = [</span><br><span class=\"line\">    &#123; name: &#x27;que_name&#x27;, alias: &#x27;q&#x27;, type: String &#125;,</span><br><span class=\"line\">    &#123; name: &#x27;payload&#x27;, alias: &#x27;p&#x27;, type: String &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\"></span><br><span class=\"line\">const options = commandlineargs(optionDefinitions)</span><br><span class=\"line\">console.log(&quot;options-&gt;&quot;, options)</span><br><span class=\"line\"></span><br><span class=\"line\">var deft_q = &quot;james&quot;;</span><br><span class=\"line\">var deft_payload = [ &quot;cooking&quot;, &quot;slacking&quot;, &quot;hacking&quot; ];</span><br><span class=\"line\"></span><br><span class=\"line\">if (Object.keys(options).length != 0) &#123;</span><br><span class=\"line\">    deft_q = options.que_name</span><br><span class=\"line\">    deft_payload  = options.payload</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">    </span><br><span class=\"line\">var data = &#123;</span><br><span class=\"line\">    topicname: deft_q,</span><br><span class=\"line\">    payload: deft_payload</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(&quot;sending...&quot;, data)</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&#x27;http://localhost:8000/enque&#x27;, &#123;</span><br><span class=\"line\">    method: &#x27;post&#x27;,</span><br><span class=\"line\">    body: JSON.stringify(data),</span><br><span class=\"line\">    headers: &#123; &#x27;Content-Type&#x27; : &#x27;application/json&#x27; &#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .then(res =&gt; res.json())</span><br><span class=\"line\">    .then(json =&gt; console.log(json));</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"conclusion\">Conclusion<a title=\"#conclusion\" href=\"#conclusion\"></a></h1>\n<p>This article described the front-door code for the message queue and demonstrated what the enqueue function would look like.  The fundamental data structure of the message queue is a hash table called topic-hash.  The system is composed of 3 parts: the front-door dispatcher, the data structures to store messages on topics and the middle ware code to manipulate that data structure. The code also demonstrated a node js based program to enqueue messages.</p>\n","prev":{"title":"A-message-queue-in-racket-part-3","link":"2021/10/22/A-message-queue-in-racket-part-3"},"next":{"title":"Using Racket to define a message queue - part 1","link":"2021/10/13/A-message-Queue-in-Racket"},"plink":"http://muguira-james.github.io/2021/10/22/A-message-queue-racket-part-2/","toc":[{"id":"table-of-contents:","title":"Table of Contents:","index":"1"},{"id":"introduction","title":"Introduction","index":"2"},{"id":"middle-layer","title":"Middle Layer","index":"3"},{"id":"testing-what-we-have","title":"Testing what we have","index":"4"},{"id":"conclusion","title":"Conclusion","index":"5"}],"reading_time":"1772 words in 12 min"}