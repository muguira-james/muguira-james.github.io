{"title":"Using Racket in Docker containers","date":"2021-09-20T17:27:12.000Z","date_formatted":{"ll":"Sep 20, 2021","L":"09/20/2021","MM-DD":"09-20"},"link":"2021/09/20/2021-09-20-Docker-with-racket","tags":["Docker","Racket"],"categories":["Containers","Programming"],"updated":"2022-01-29T23:12:11.206Z","content":"<p>Using Racket in Docker</p>\n<span id=\"more\"></span>\n<h1 id=\"introduction\">Introduction<a title=\"#introduction\" href=\"#introduction\"></a></h1>\n<p>The Racket programming language is an implementation of the Scheme standard. Racket is very well supported. It has great capabilities as a teaching language. To get  started with Racket see <a href=\"https://racket-lang.org\">https://racket-lang.org</a></p>\n<p>This post came about because one of the people on my team said that lisp and scheme were “no good for production, becuase you  can’t put them in containers.” This post will describe how to put Racket into a Docker container. In production environments, deploying software can be problematic. For example, many programming languages / solutions require loading additional components and libraries beyond the standard set that is shipped with the language.</p>\n<p>This post assumes you have installed both Racket and Docker on your machine. I also use the command line tool dive to inspect the container contents. Dive is a great tool. last, but very important, I assume you are working on linux. I use ubuntu and this article will build using the ubuntu latest docker image.</p>\n<p>Because we are pulling a ubuntu image into the container to serve as a base image, you have to be consistent.  The Racket-lang compilation tools build for the host they run on.  In this case, I use / develop on ubuntu. You will have executable format problems if you try and work this example on a mac or on windows.</p>\n<h1 id=\"a-simple-case-of-saying-hello\">A simple case of saying hello<a title=\"#a-simple-case-of-saying-hello\" href=\"#a-simple-case-of-saying-hello\"></a></h1>\n<p>This post covers 2 things:</p>\n<ul>\n<li>building the basic container with a working racket program,</li>\n<li>exploiting Racket tooling to create a compiled version of the sample program.</li>\n</ul>\n<p>First, we need a simple program.</p>\n<p>Our first sample Racket program is very simple. It will make use of Racket’s http services stack. This post is not a tutorial for Racket, there are many very well written tutorials in the Racket documentation.</p>\n<p>Our basic program will start, initialize Racket’s web stack, and return a message when somebody hits the URL with a browser.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#lang racket</span><br><span class=\"line\"></span><br><span class=\"line\">; bring in the racket web stack</span><br><span class=\"line\">(require web-server/servlet</span><br><span class=\"line\">         web-server/servlet-env)</span><br><span class=\"line\"></span><br><span class=\"line\">; this function will return some html to the requestor</span><br><span class=\"line\">(define (start request)</span><br><span class=\"line\">  (response/xexpr</span><br><span class=\"line\">   &#x27;(html</span><br><span class=\"line\">     (head (title &quot;James and his blog&quot;))</span><br><span class=\"line\">     (body (h1 &quot;My Blog under construction&quot;)))))</span><br><span class=\"line\"></span><br><span class=\"line\">; start the server on port 8000 and don&#x27;t launch a browser</span><br><span class=\"line\">; #:listen-ip tells the network stack to listen on all ip addresses</span><br><span class=\"line\">; #:launch-broswer says don&#x27;t start a new browser</span><br><span class=\"line\">(serve/servlet start #:port 8000 #:listen-ip #f #:launch-browser? #f)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>From a container perspective, this program highlights a couple of concerns:</p>\n<ul>\n<li>The container will be running a server capable of responding to browser requests,</li>\n<li>The container will require a port to be opened,</li>\n<li>The program needs to have all of its dependencies loaded into the container.</li>\n</ul>\n<p>Racket, installed on my Mac is a dynamically linked application. That means libraries are loaded at run time, from system libraries. That is our first huddle to over come. Docker containers create a self contained environment. That means all dynamic code and dependent libraries needs to be inside inside the container.</p>\n<p>Let’s take a simple approach to get something running. Then we’ll improve it over several steps. As a first step, we’ll create a docker configuration file.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">FROM ubuntu</span><br><span class=\"line\">RUN apt update -y &amp;&amp; apt install -y tzdata &amp;&amp; apt install -y racket</span><br><span class=\"line\">ENV TZ=&quot;America/New_York&quot;</span><br><span class=\"line\">WORKDIR /app</span><br><span class=\"line\">COPY web1.rkt .</span><br><span class=\"line\">EXPOSE 8080</span><br><span class=\"line\">CMD [&quot;racket&quot;, &quot;web1.rkt&quot;]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>That Dockerfile will create the container, update ubuntu to it’s latest  configuration, install Racket into the container, expose the port and run racket with the mentioned script. Notice, that I had to do something with the time zone. Ubuntu does not include time zone utilities and tools in the latest docker image.</p>\n<p>Let’s see this in action. The following first builds the container. The second line runs the comtainer:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ docker build -t foo .</span><br><span class=\"line\">$ docker run -it -p 8000:8000 foo </span><br><span class=\"line\">Your Web application is running at http://localhost:8080.</span><br><span class=\"line\">Stop this program at any time to terminate the Web Server.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>If you open Firefox and enter <a href=\"http://localhost:8000\">http://localhost:8000</a> in the URL bar you should see:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Welcome to the Racket Web Server</span><br><span class=\"line\"></span><br><span class=\"line\">Find out more about writing servlets by reading the Continue tutorial in the Help Desk.</span><br><span class=\"line\"></span><br><span class=\"line\">Find out more about the server by reading its reference manual in the Help Desk.</span><br><span class=\"line\"></span><br><span class=\"line\">Please replace this page with your favorite index page.</span><br><span class=\"line\"></span><br><span class=\"line\">Powered by Racket</span><br><span class=\"line\"></span><br><span class=\"line\">For more information on Racket, please follow the icon link.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Humm,  that was not what  I expected?  Reading into the Racket docs, I see I need to use a different URL:  <a href=\"http://localhost:8000/servlets/standalone.rkt\">http://localhost:8000/servlets/standalone.rkt</a>. Ok, that worked, the container builds and runs. Use Ctl-C to stop things. Let us examine what we have created. Issue the following command:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ docker images</span><br><span class=\"line\">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class=\"line\">foo          latest    836d83e4f6b9   44 hours ago   490MB</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"packaging-without-loading-racket\">Packaging without loading Racket<a title=\"#packaging-without-loading-racket\" href=\"#packaging-without-loading-racket\"></a></h1>\n<p>On my machine, I see a large container, wieghing in at 490 megabytes. That is pretty large for such a simple program. Using the program “dive” i can see that the first line of the Dockerfile: “FROM ubnutu” created a 73 MB layer in the container. The sencond line, which updates ubuntu and installs Racket, adds 417 MB !!! Doing the copy of the web1.rkt script adds 352 bytes.</p>\n<p>We can improve this. We loaded the full Racket environment into the container. We don’t need to do that. Our current setup assumes we will run Racket and let it run the web1.rkt script. So, we are interpreting the script. Ideally, we should be able to compile our Racket script.  Racket has command line tools, let’s explore those.</p>\n<p>The Racket documentation describes a set of tools for compiling and distributing Racket code. We’ll now explore raco. The raco tool provides a number of tools that are run from the command line. This is perfect for including racket into Ci/CD pipelines. We will explore raco exe and raco distribute.</p>\n<p>Let’s go back to what I said earlier about Racket being a dynamically linked  language.  Most  modern programming languages assume you are going to link your program dynamically. The executable will depend on libraries loading as the program is running. In a unix environment (Mac &amp; Linux), there is an environment  variable  called “LD_LIBRARY_PATH” that points to where system libraries are loaded from. For Windows machines  see <a href=\"https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order?redirectedfrom=MSDN#search_order_for_desktop_applications\">https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order?redirectedfrom=MSDN#search_order_for_desktop_applications</a>.</p>\n<p>To make a ccontainer work, we  need to gather all of  the dependencies together and load them all  into the  container.  This means we have to ;</p>\n<ul>\n<li>compile our Racket code into a  standalone executable,</li>\n<li>have just the Racket run-time load into the container vs. the entire Racket environment,</li>\n<li>have all libraries loaded into  the  container.</li>\n</ul>\n<p>Raco exe is used to compile our script. Instead of interpreting, after using raco exe, we get a stand alone executable. This means that the Racket run-time is included in. Raco exe alone creates a program that dependes on having the racket system installed on your machine. That is not quite what we want but let’s explore it.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">raco exe web1.rkt</span><br><span class=\"line\">$ ls -lh</span><br><span class=\"line\">-rw-r--r--   1 muguira  staff   122B Sep 23 19:08 Dockerfile</span><br><span class=\"line\">-rwxr-xr-x   1 muguira  staff    62M Sep 26 13:37 web1</span><br><span class=\"line\">-rw-r--r--   1 muguira  staff   352B Sep 24 17:43 web1.rkt</span><br><span class=\"line\">$</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>The directoy listing shows a 62 MB executable (web1).  That is a lot better than 490MB. However, that executable does depend on a working Racket installation.</p>\n<p>What we need is a way to combine the parts of Racket we need and the script to produce a working program. Raco distribute is the command for that! Raco Distribute creates a pacckage that can be run on other machines (without Racket installed). The command places the standalone executable and all dependencies into a directory.  For this example I’ll call that directory “build”.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">raco distribute build web1</span><br><span class=\"line\">$ ls -lh</span><br><span class=\"line\">total 126120</span><br><span class=\"line\">-rw-r--r--   1 muguira  staff   122B Sep 23 19:08 Dockerfile</span><br><span class=\"line\">drwxr-xr-x   4 muguira  staff   128B Sep 26 13:43 build</span><br><span class=\"line\">-rwxr-xr-x   1 muguira  staff    62M Sep 26 13:37 web1</span><br><span class=\"line\">-rw-r--r--   1 muguira  staff   352B Sep 24 17:43 web1.rkt</span><br><span class=\"line\"></span><br><span class=\"line\">$ du -d1 -h build</span><br><span class=\"line\"> 62M\tbuild/bin</span><br><span class=\"line\">5.7M\tbuild/lib</span><br><span class=\"line\"> 67M\tbuild</span><br><span class=\"line\"></span><br><span class=\"line\">$ ls -lh build/bin</span><br><span class=\"line\">total 125992</span><br><span class=\"line\">-rwxr-xr-x  1 muguira  staff    62M Sep 26 13:43 web1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>The result is a 67MB self-contained directory that contains everything we want in one place. Under build/bin we see the executable  file web1, which is 62MB. The build/lib directory contains all of the dependencies. Now let’s change the Dockerfile and compare our results:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">FROM ubuntu</span><br><span class=\"line\">RUN apt update -y &amp;&amp; apt install -y tzdata</span><br><span class=\"line\">ENV TZ=&quot;America/New_York&quot;</span><br><span class=\"line\">WORKDIR /app</span><br><span class=\"line\">COPY build .</span><br><span class=\"line\">EXPOSE 8080</span><br><span class=\"line\">CMD [&quot;/app/bin/web1&quot;]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Notice, that we DO NOT update ubuntu or install Racket. Instead, we set a working directory in the container called /app and we copy the build directory into /app in the container. We still expose the port. Last, we change the command to run our program to point to “/app/bin/web1”</p>\n<p>To compare, let’s change the name of the container for this build to be foosmall:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ docker build -t foosmall .</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker images</span><br><span class=\"line\">REPOSITORY   TAG       IMAGE ID       CREATED              SIZE</span><br><span class=\"line\">foo          latest    fee0476d757a   About a minute ago   490MB</span><br><span class=\"line\">foosmall     latest    24d628917cf5   8 minutes ago        143MB</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Our final container size is 143 MB. Using dive, we see that the docker copy added 70MB to the 73 Mb ubuntu base image.</p>\n<h1 id=\"conclusion\">Conclusion<a title=\"#conclusion\" href=\"#conclusion\"></a></h1>\n<p>This post walked through the steps to create a docker container with a working Racket program.  The small Racket program demonstrated how to create a simple web server that could reply with html to a browser.  Our first container effort created a large 490 MB container with the full Racket environment installed  inside the container. From a security point of view this is less than optmial.  We don’t need a full Racket install in the container to reply to a simple request. Our second effort reduced the container size and placed only the elements of the Raclet run-time in the container. The Racket environment supplied two commands  that helped us create a standalone executable. Finally we used docker commands to copy that executable into the container and expose the proper  ports.</p>\n","prev":{"title":"Using Racket to define a message queue - part 1","link":"2021/10/13/A-message-Queue-in-Racket"},"next":{"title":"Using Express to serve a React app","link":"2018/10/26/2018-10-25-Using-Express-to-serve-a-React-JS-app"},"plink":"http://muguira-james.github.io/2021/09/20/2021-09-20-Docker-with-racket/","toc":[{"id":"introduction","title":"Introduction","index":"1"},{"id":"a-simple-case-of-saying-hello","title":"A simple case of saying hello","index":"2"},{"id":"packaging-without-loading-racket","title":"Packaging without loading Racket","index":"3"},{"id":"conclusion","title":"Conclusion","index":"4"}],"reading_time":"1837 words in 12 min"}