{"title":"A-message-queue-in-racket-part-5","date":"2021-10-25T16:31:45.000Z","date_formatted":{"ll":"Oct 25, 2021","L":"10/25/2021","MM-DD":"10-25"},"link":"2021/10/25/A-message-queue-in-racket-part-5","tags":["Racket"],"categories":["Programming","message queue"],"updated":"2022-03-29T17:25:38.044Z","content":"<p>The 5th article in the series, testing</p>\n<span id=\"more\"></span>\n<h1 id=\"table-of-contents\">Table of Contents<a title=\"#table-of-contents\" href=\"#table-of-contents\"></a></h1>\n<ul>\n<li>Code organization, racket require and provide</li>\n<li>Test cases</li>\n<li>Github Actions</li>\n<li>Conclusion</li>\n</ul>\n<h1 id=\"introduction\">Introduction<a title=\"#introduction\" href=\"#introduction\"></a></h1>\n<p>Up to this point we have created a working message queue.  It uses Racket’s http stack and presents a simple to use http POST API to add / delete messages in topics. It also has an administrative API to explore and manipulate the topic list and data stored in queues under specific topics.</p>\n<p>The system is architected as a front-door that defines the http interface. The middleware defines the logic to handle manipulating the hash table. Last, we implement a Racket hash table to organize the message queue.</p>\n<p>This article will expand on that base by adding testing. We use the Racket rackunit test suite.</p>\n<h1 id=\"preliminaries\">Preliminaries<a title=\"#preliminaries\" href=\"#preliminaries\"></a></h1>\n<p>Last article, we spilt the code into 2 files, front-door.rkt and middleware.rkt. The front-door code handles http interfacing. We are not going to test that functionality with rackunit.</p>\n<p>We will use rackunit to test the middleware functionality. The rackunit test suite provides a rich set of verbs to evaluate the state of the system. Rackunit provides:</p>\n<ul>\n<li>a basic capability to check if variables or statement evaluate properly</li>\n<li>a test-case verb to group tests together</li>\n<li>a test-suite verb to group test around a theme.</li>\n</ul>\n<p>I recommend you consult the Racket documentation for further <a href=\"https://docs.racket-lang.org/rackunit/\" target=\"_blank\">details</a>. We are going to keep our tests simple. We’ll evaluate the functionality of each method in the middleware.rkt file, developing tests and evaluating edge cases. This set of tests will be very simple, really just a demonstration. Rackunit has as much capability as any competing test framework I have used.</p>\n<p>The test file we’ll use is called test-middleware.rkt. As I said before, it will contain tests for each method in the middleware module. To use rackunit, we have to first ‘require’ it in. We then require in any Racket support libraries. Finally we require in the middleware.rkt module. Requiring “middleware.rkt” will bring in all of the definitions and variables that are exposed through a “provide” statement.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#lang racket</span><br><span class=\"line\"></span><br><span class=\"line\">(require rackunit)</span><br><span class=\"line\"></span><br><span class=\"line\">(require web-server/servlet) </span><br><span class=\"line\">(require web-server/servlet-env)</span><br><span class=\"line\">(require json)</span><br><span class=\"line\">(require data/queue)</span><br><span class=\"line\"></span><br><span class=\"line\">(require &quot;middleware.rkt&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Now we can create our first test. Contains-topic inspects the topic-hash to see if a specific topic-name exists.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(test-case &quot;middleware: contains-topic&quot;</span><br><span class=\"line\">           ; setup by adding a topic &#x27;key and an element &#x27;aaa</span><br><span class=\"line\">           (add-data-to-topic &#x27;key &#x27;aaa)</span><br><span class=\"line\">           (check-equal? (contains-topic &#x27;key) #t &quot;should contain the test topic&quot;)</span><br><span class=\"line\">           (check-equal? (contains-topic &#x27;foo) #f &quot;should not contain &#x27;foo&#x27; topic&quot;)</span><br><span class=\"line\">           (check-equal? (hash-count topic-hash) 1 &quot;should only be a single topic&quot;)</span><br><span class=\"line\">           ; clean up before next test</span><br><span class=\"line\">           (hash-remove! topic-hash &#x27;key)</span><br><span class=\"line\">           )</span><br></pre></td></tr></table></figure>\n<p>We first, add a topic named 'key and add some data 'aaa. Then we evaluate different rackunit check-equal clauses to determine if the topic hash is setup correctly.  In this case, we ask:</p>\n<ul>\n<li>is there only 1 topic name</li>\n<li>there should not be a 'foo topic, we did not add that</li>\n<li>the topic-hash should only have a single topic</li>\n</ul>\n<p>Finally, if each of these test cases pass, we clean up the topic-hash to get it ready for the next test.  It is a best practice to leave your data structures in a known state at the end of each test. Don’t string tests together, unless you are using rackunit verbs like “test-suite”.</p>\n<p>next we test add-data-to-topic. There is a lot to test here…</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(test-case &quot;middleware: add-data-to-topic&quot;</span><br><span class=\"line\">           ; first, should be nothing in the topic hash</span><br><span class=\"line\">           (check-equal? (hash-count  topic-hash) 0 &quot;should be empty&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">           ; add a single topic and 1 item</span><br><span class=\"line\">           (add-data-to-topic &#x27;key &#x27;aaa)</span><br><span class=\"line\">           (check-equal? (hash-count topic-hash) 1 &quot;should only be a single topic&quot;)</span><br><span class=\"line\">           (check-equal? (queue-length (hash-ref topic-hash &#x27;key)) 1 &quot;should only be a  single item in the queue&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">           ; add a 2nd item to the test topic</span><br><span class=\"line\">           (add-data-to-topic &#x27;key &#x27;bbb)</span><br><span class=\"line\">           (check-equal? (hash-count topic-hash) 1 &quot;should be a single topic&quot;)</span><br><span class=\"line\">           (check-equal? (queue-length (hash-ref topic-hash &#x27;key)) 2 &quot;should only be a  single item in the queue&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">           (add-data-to-topic &#x27;key2 &#x27;zzz)</span><br><span class=\"line\">           (check-equal? (hash-count topic-hash) 2 &quot;should be 2 topics now&quot;)</span><br><span class=\"line\">           (check-equal? (queue-length (hash-ref topic-hash &#x27;key)) 2 &quot;should only be 2 items in the &#x27;key queue&quot;)</span><br><span class=\"line\">           (check-equal? (queue-length (hash-ref topic-hash &#x27;key2)) 1 &quot;should only be 1 item in the &#x27;key2 queue&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">           (add-data-to-topic &#x27;key2 &quot;go man go&quot;)</span><br><span class=\"line\">           (check-equal? (queue-length (hash-ref topic-hash &#x27;key2)) 2 &quot;should be 2 items in the &#x27;key2 queue&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">           (add-data-to-topic &#x27;key2 &quot;[ &#x27;foo &#x27;bar ]&quot;)</span><br><span class=\"line\">           (check-equal? (queue-length (hash-ref topic-hash &#x27;key2)) 3 &quot;should be 2 items in the &#x27;key2 queue&quot;)</span><br><span class=\"line\">           (check-equal? (dequeue! (hash-ref topic-hash &#x27;key2)) &#x27;zzz &quot;should be the first string zzz&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">           </span><br><span class=\"line\">           (hash-remove! topic-hash &#x27;key)</span><br><span class=\"line\">           (hash-remove! topic-hash &#x27;key2)</span><br><span class=\"line\">           )</span><br></pre></td></tr></table></figure>\n<p>First, make sure the topic-hash is clear. Then, add a key and data and test to make sure there is only 1 key and 1 piece of data. Going on, add a 2nd data item and test. Then add a 2nd key + data and evaluate the topic-hash state to make sure it is correct. Finally, clean up the topic-hash, to prepare for the next test.</p>\n<p>The method to test remove-data-from-topic. The topic-hash should have the input topic present and there should be data in the queue associated with the topic. Here is the original remove code:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(define (remove-data-from-topic topic-name)</span><br><span class=\"line\">  (if (contains-topic topic-name)</span><br><span class=\"line\">      (begin</span><br><span class=\"line\">        (let* ([datam (dequeue! (get-queue-for-topic topic-name))])</span><br><span class=\"line\">          ;(displayln (format &quot;::-&gt;~v&quot; datam)</span><br><span class=\"line\">          datam))</span><br><span class=\"line\">      (begin</span><br><span class=\"line\">        (let* ([rtn (format &quot;did not find topic ~v~%&quot; topic-name)])</span><br><span class=\"line\">          (display rtn)</span><br><span class=\"line\">          rtn))))</span><br></pre></td></tr></table></figure>\n<p>It may not be obvious, but this code does not work correctly. The code says: “if there is a topic by this name, dequeue the first thing on the queue and return it”. The tests we will run follow:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(test-case &quot;middleware: remove-data-from-topic&quot;</span><br><span class=\"line\">           ; first, should be nothing in the topic hash</span><br><span class=\"line\">           (check-equal? (hash-count  topic-hash) 0 &quot;should be empty&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">           ; add a single topic and 1 item</span><br><span class=\"line\">           (add-data-to-topic &#x27;key &#x27;aaa)</span><br><span class=\"line\">           (check-equal? (hash-count topic-hash) 1 &quot;should only be a single topic&quot;)</span><br><span class=\"line\">           (check-equal? (queue-length (hash-ref topic-hash &#x27;key)) 1 &quot;should only be a  single item in the queue&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">           ; ... now remove stuff</span><br><span class=\"line\"></span><br><span class=\"line\">           (check-equal? (remove-data-from-topic &#x27;key) &#x27;aaa  &quot;remove only item in the  queue&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">           ; now remove another item - this should fail.</span><br><span class=\"line\">           ;(check-equal? (remove-data-from-topic &#x27;key) &quot;&#123; \\&quot;error\\&quot;: \\&quot;no data in queue &#x27;key\\&quot; &#125;\\n&quot; &quot;should be nothing in the queue&quot;)</span><br><span class=\"line\">           )</span><br></pre></td></tr></table></figure>\n<p>When we run the tests, we can use ‘DrRacket’ or run from the command line. If we run from the command line, we see the following:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ raco test: &quot;test-middleware.rkt&quot;</span><br><span class=\"line\">raco test: &quot;test-middleware.rkt&quot;</span><br><span class=\"line\">--------------------</span><br><span class=\"line\">middleware: remove-data-from-topic</span><br><span class=\"line\">ERROR</span><br><span class=\"line\">name:       check-equal?</span><br><span class=\"line\">location:   test-middleware.rkt:63:11</span><br><span class=\"line\"></span><br><span class=\"line\">dequeue!: expected argument of type &lt;non-empty queue&gt;; given: #&lt;queue&gt;</span><br><span class=\"line\">1/3 test failures</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>The test output shows that we had an error.  The Racket system found an empty queue and stopped the tests. If we look at the code we see that we did not test to see if the queue was empty, we just try to dequeue the next item.</p>\n<p>To fix this, let’s test the queue first before we try to pop something off it. We can use “queue-empty?”. If the queue is empty, no point in trying to pop an item off, just return the error string.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(define (remove-data-from-topic topic-name)</span><br><span class=\"line\">  ; do we have this topic?</span><br><span class=\"line\">  (if (contains-topic topic-name)</span><br><span class=\"line\">      ; is there something in the queue?</span><br><span class=\"line\">      (if (queue-empty? (get-queue-for-topic topic-name))</span><br><span class=\"line\">          ; no return an error</span><br><span class=\"line\">          (let* ([rtn (format &quot;&#123; \\&quot;error\\&quot;: \\&quot;no data in queue ~v\\&quot; &#125;~%&quot; topic-name)])</span><br><span class=\"line\">            (displayln rtn)</span><br><span class=\"line\">            rtn)</span><br><span class=\"line\">          ; yes, build a valid return  json</span><br><span class=\"line\">          (format  &quot;&#123; \\&quot;topic-name\\&quot;: ~s \\&quot;payload\\&quot;: ~v &#125;&quot; topic-name (dequeue! (get-queue-for-topic topic-name)))</span><br><span class=\"line\"></span><br><span class=\"line\">          )</span><br><span class=\"line\">      (begin</span><br><span class=\"line\">        (let* ([rtn (format &quot;&#123; \\&quot;error\\&quot;: \\&quot;did not find topic ~v~%&quot; topic-name)])</span><br><span class=\"line\">          (display rtn)</span><br><span class=\"line\">          rtn))))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Ok, found and fixed that bug. Now, let’s examine geet-queue-for-topic. If it SHOULD return a valid queue if the topic is present. But the way it is coded, if the topic is not present, we generate an error.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(define (get-queue-for-topic topic-name)</span><br><span class=\"line\">  ; just return the queue for this topic,</span><br><span class=\"line\">  ;  somebody  else has to check to see if the topic-name exists</span><br><span class=\"line\">      (hash-ref topic-hash topic-name))</span><br></pre></td></tr></table></figure>\n<p>Not good! Since we always test the returned queue to see if it is empty let’s always return a valid queue. New code:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(define (get-queue-for-topic topic-name)</span><br><span class=\"line\">  ; just return the queue for this topic,</span><br><span class=\"line\">  ;  somebody  else has to check to see if the topic-name exists</span><br><span class=\"line\">  (if (contains-topic topic-name)</span><br><span class=\"line\">      (hash-ref topic-hash topic-name)</span><br><span class=\"line\">      (make-queue)))</span><br></pre></td></tr></table></figure>\n<h1 id=\"testing-on-checkin\">Testing on checkin<a title=\"#testing-on-checkin\" href=\"#testing-on-checkin\"></a></h1>\n<p>Finally, let’s setup our git repo so that the tests run each time we check our code it. Github provides “actions”, which can do a number of things for us.  For example: run tests, package our code for deployment to containers, or reformat code according to test standards.</p>\n<p>The Github action code is stored in a special directory in the repo called “.github/workflows”. We place a file there that provides instructions for github actions to follow. In our case, we’ll use:</p>\n<ul>\n<li>A standard github action ubuntu worker node,</li>\n<li>Install Racket on the worker</li>\n<li>Run raco test test-middleware.rkt</li>\n</ul>\n<p>Here is the action code;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name: Makefile CI</span><br><span class=\"line\"></span><br><span class=\"line\">on:</span><br><span class=\"line\">  push:</span><br><span class=\"line\">    branches: [ main ]</span><br><span class=\"line\">  pull_request:</span><br><span class=\"line\">    branches: [ main ]</span><br><span class=\"line\"></span><br><span class=\"line\">jobs:</span><br><span class=\"line\">  build:</span><br><span class=\"line\"></span><br><span class=\"line\">    runs-on: ubuntu-latest</span><br><span class=\"line\"></span><br><span class=\"line\">    steps:</span><br><span class=\"line\">    - uses: actions/checkout@v2</span><br><span class=\"line\">    </span><br><span class=\"line\"> </span><br><span class=\"line\">      </span><br><span class=\"line\">    - name: Install dependencies</span><br><span class=\"line\">      run: |</span><br><span class=\"line\">        sudo apt-get update</span><br><span class=\"line\">        sudo apt-get install -y racket</span><br><span class=\"line\">        raco test test-middleware.rkt</span><br></pre></td></tr></table></figure>\n<p>A break down of the statements in the file follows:</p>\n<ul>\n<li>name: Makefile CI -  I choose this because it was very close to what I needed</li>\n<li>on: … - push or pull requests, run the action</li>\n<li>jobs: - this is the action steps</li>\n<li>build: runs-on - tells git to grab a ubuntu-latest worker</li>\n<li>steps: there are 3</li>\n<li>uses: actions/checkout@2 is a git check out step from the market place</li>\n<li>name: &amp; run: update the ubuntu container, install racket and run our tests</li>\n</ul>\n<p>If something fails, you receive an email complaining about the failure. This is great for working in teams of people. Each checkin will notify everybody of the code status and alert people for problems.</p>\n<h1 id=\"conclusion\">Conclusion<a title=\"#conclusion\" href=\"#conclusion\"></a></h1>\n<p>Testing your code is very important. As we saw here, the code worked for the easy path cases. It failed and would have had strange behavior if we had not caught the remove-data-from-topic bug or the get-queue-for-topic bug. Racket’s testing framework rackunit is very robust and provides a lot more capability than we used here. But these tests demonstrate how to get started.</p>\n","prev":{"title":"Using-big-bang-for-simulation","link":"2022/01/09/Using-big-bang-for-simulation"},"next":{"title":"A-message-queue-in-racket-part-4","link":"2021/10/24/A-message-queue-in-racket-part-4"},"plink":"http://muguira-james.github.io/2021/10/25/A-message-queue-in-racket-part-5/","toc":[{"id":"table-of-contents","title":"Table of Contents","index":"1"},{"id":"introduction","title":"Introduction","index":"2"},{"id":"preliminaries","title":"Preliminaries","index":"3"},{"id":"testing-on-checkin","title":"Testing on checkin","index":"4"},{"id":"conclusion","title":"Conclusion","index":"5"}],"reading_time":"1985 words in 13 min"}