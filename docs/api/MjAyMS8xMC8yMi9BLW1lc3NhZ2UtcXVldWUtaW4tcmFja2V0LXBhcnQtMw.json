{"title":"A-message-queue-in-racket-part-3","date":"2021-10-23T01:14:10.000Z","date_formatted":{"ll":"Oct 22, 2021","L":"10/22/2021","MM-DD":"10-22"},"link":"2021/10/22/A-message-queue-in-racket-part-3","tags":["Racket"],"categories":["Programming","message queue"],"updated":"2022-01-26T02:24:54.563Z","content":"<p>This is the third part of the series</p>\n<span id=\"more\"></span>\n<h1 id=\"table-of-contents:\">Table of Contents:<a title=\"#table-of-contents:\" href=\"#table-of-contents:\"></a></h1>\n<ul>\n<li>Introduction and review of the Front-door shell</li>\n<li>dequeue - deleting messages from a topic</li>\n<li>The Admin interface</li>\n<li>Conclusion</li>\n</ul>\n<h1 id=\"introduction\">Introduction<a title=\"#introduction\" href=\"#introduction\"></a></h1>\n<p>The first 2 parts of this series introduced the scaffolding and 2 API calls. We are creating a message queuing system, similar to Rabbit MQ or Apache ActiveMQ. The idea is to create a server that can be used to store and retrieve data. The server interface is an API consisting of 2 different layers: a user interface for adding and deleting items from queues assoicated with topics; and an administration interface that returns the number of topics, list of topics, data for a topic and allows us to remove all data for a topic.</p>\n<p>At this point we have the scaffolding and 2 API  calls implemented: Hello, which is a monitoring API; and enqueue which is used to add items into the queue for a given topic. This time we will implement; dequeue, which completes the user interface. We will also implement the administrative interface consisting of topic-list, topic-data, topic-count, topic-drain, topic-remove and drain-queue. That is  a lot, let’s get going.</p>\n<p>First, to set expectations, here is the complete program to date:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">(require web-server/servlet) </span><br><span class=\"line\">(require web-server/servlet-env)</span><br><span class=\"line\">(require json)</span><br><span class=\"line\">(require data/queue)</span><br><span class=\"line\"></span><br><span class=\"line\">;; a hash is structured as a topic and a queue</span><br><span class=\"line\">(define topic-hash (make-hash))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">; Hello - say hello and add the date and time</span><br><span class=\"line\">(define (hello request)</span><br><span class=\"line\">  ; just say nothing useful</span><br><span class=\"line\">  (http-response &quot;&lt;div&gt;welcome to &lt;span style=\\&quot;color:blue\\&quot;&gt;jamQ&lt;/span&gt;&lt;/div&gt;&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">;</span><br><span class=\"line\">; handle adding  a message to a topic</span><br><span class=\"line\">(define (add-data-to-topic key data)</span><br><span class=\"line\">  ;; check to see if key is in the topic-hash and add data to the correct topic</span><br><span class=\"line\">  (if (contains-topic key)</span><br><span class=\"line\">      (enqueue! (hash-ref topic-hash key) data)</span><br><span class=\"line\">      (begin</span><br><span class=\"line\">        (let ([q (make-queue)])</span><br><span class=\"line\">          (enqueue! q data)</span><br><span class=\"line\">          (hash-set! topic-hash key q)))))</span><br><span class=\"line\"></span><br><span class=\"line\">;</span><br><span class=\"line\">; helper function to return a byte array</span><br><span class=\"line\">(define (request-&gt;jshash request)</span><br><span class=\"line\">  (string-&gt;jsexpr (bytes-&gt;string/utf-8 (request-post-data/raw request))))</span><br><span class=\"line\"></span><br><span class=\"line\">;</span><br><span class=\"line\">; front-door of the enqueue function</span><br><span class=\"line\">(define (enque request)</span><br><span class=\"line\">  ; put something in a queue</span><br><span class=\"line\">  ; input: &#123; topic: &quot;name&quot;, payload: &quot;data-type&quot; &#125;</span><br><span class=\"line\">  (let* ([hsh (request-&gt;jshash request)]</span><br><span class=\"line\">         [topic-name (hash-ref hsh &#x27;topicname)]</span><br><span class=\"line\">         [payload-data (hash-ref hsh &#x27;payload)])</span><br><span class=\"line\">    (begin         </span><br><span class=\"line\">      (add-data-to-topic topic-name payload-data)</span><br><span class=\"line\">      (displayln</span><br><span class=\"line\">       (format</span><br><span class=\"line\">        &quot;enq: name: ~v: data: ~v hash-size: ~v hash-keys: ~v~%&quot;</span><br><span class=\"line\">        topic-name payload-data (hash-count topic-hash) (hash-keys topic-hash)))</span><br><span class=\"line\">      (let ([rtn (make-hash)])</span><br><span class=\"line\">        (hash-set! rtn &#x27;topic-name topic-name)</span><br><span class=\"line\">        (hash-set! rtn &#x27;data payload-data)</span><br><span class=\"line\">        (hash-set! rtn &#x27;count (hash-count topic-hash))</span><br><span class=\"line\">        (hash-set! rtn &#x27;keys (hash-keys topic-hash))</span><br><span class=\"line\">        (displayln (with-output-to-string (lambda () (write-json  rtn))))</span><br><span class=\"line\">        (http-response (with-output-to-string (lambda  () (write-json rtn))))))))</span><br><span class=\"line\"></span><br><span class=\"line\">;</span><br><span class=\"line\">; return a byte array formated like an http response</span><br><span class=\"line\">(define (http-response content)  </span><br><span class=\"line\">  (response/full</span><br><span class=\"line\">    200                  ; HTTP response code.</span><br><span class=\"line\">    #&quot;OK&quot;                ; HTTP response message.</span><br><span class=\"line\">    (current-seconds)    ; Timestamp.</span><br><span class=\"line\">    TEXT/HTML-MIME-TYPE  ; MIME type for content.</span><br><span class=\"line\">    &#x27;()                  ; Additional HTTP headers.</span><br><span class=\"line\">    (list                ; Content (in bytes) to send to the browser.</span><br><span class=\"line\">      (string-&gt;bytes/utf-8 content))))</span><br><span class=\"line\"></span><br><span class=\"line\">;</span><br><span class=\"line\">; look up table for the routing of our API</span><br><span class=\"line\">(define-values (dispatch generate-url)</span><br><span class=\"line\">  ;; URL routing table (URL dispatcher).</span><br><span class=\"line\">  (dispatch-rules</span><br><span class=\"line\">   [(&quot;&quot;) hello]</span><br><span class=\"line\">   [(&quot;hello&quot;) hello]  ; check to see if the service is working</span><br><span class=\"line\">   [(&quot;enque&quot;) #:method &quot;post&quot; enque]</span><br><span class=\"line\">   [(&quot;deque&quot;) #:method &quot;post&quot; deque]</span><br><span class=\"line\">   [(&quot;topic-list&quot;) topic-list]</span><br><span class=\"line\">   [(&quot;topic-count&quot;) topic-count]</span><br><span class=\"line\">   [(&quot;topic-data&quot;) #:method &quot;post&quot; topic-data]</span><br><span class=\"line\">   [else (error &quot;page not found&quot;)]))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">(define (request-handler request)</span><br><span class=\"line\">  (dispatch request))</span><br><span class=\"line\"></span><br><span class=\"line\">;; Start the server.</span><br><span class=\"line\">(serve/servlet</span><br><span class=\"line\">  request-handler</span><br><span class=\"line\">  #:launch-browser? #f</span><br><span class=\"line\">  #:quit? #f</span><br><span class=\"line\">  ; have to listen on the  right host NOT 127.0.0.1</span><br><span class=\"line\">  #:listen-ip &quot;0.0.0.0&quot;</span><br><span class=\"line\">  #:port 8000</span><br><span class=\"line\">  #:servlet-regexp #rx&quot;&quot;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"implemention-of-dequeu---deleting-message-from-a-topic\">Implemention of dequeu - deleting message from a topic<a title=\"#implemention-of-dequeu---deleting-message-from-a-topic\" href=\"#implemention-of-dequeu---deleting-message-from-a-topic\"></a></h1>\n<p>Our first function to implement is the opposite of adding an item to a topic, removing an item. In this case, we just remove and return the first  item in the queue. Before we see the implementation let’s review the architecture of the system and the topic hash data structure. The system architecture is a front door that handles http requests and responses. There is a middle layer that handles the internal data structures and finally the internal  data structures themselves.</p>\n<p><img src=\"/images/MQ-Architecture-1.png\" alt=\"system architecture\" loading=\"lazy\" class=\"φbp\"></p>\n<p>The internal data structure we are manipulating is a hash table. The keys in the hash table are the topic  names. For each key, the value is a queue with all the items associated with that topic.</p>\n<p><img src=\"/images/Racket-queue-2.png\" alt=\"internal data structure\" loading=\"lazy\" class=\"φbp\"></p>\n<p>The enqueue function checked to see if a topic name existed in the hash table, adding it and the message data if required. Deleting messages off a topic is handled by popping the top item off the queue for a topic and returning that message.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">(define (request-&gt;jshash request)</span><br><span class=\"line\">  (string-&gt;jsexpr (bytes-&gt;string/utf-8 (request-post-data/raw request))))</span><br><span class=\"line\"></span><br><span class=\"line\">(define (get-queue-for-topic topic-name)</span><br><span class=\"line\">  ; just return the queue for this topic,</span><br><span class=\"line\">  ;  somebody  else has to check to see if the topic-name exists</span><br><span class=\"line\">      (hash-ref topic-hash topic-name))</span><br><span class=\"line\"></span><br><span class=\"line\">(define (remove-data-from-topic topic-name)</span><br><span class=\"line\">  (if (contains-topic topic-name)</span><br><span class=\"line\">      (begin</span><br><span class=\"line\">        (let* ([datam (dequeue! (get-queue-for-topic topic-name))])</span><br><span class=\"line\">          ;(displayln (format &quot;::-&gt;~v&quot; datam)</span><br><span class=\"line\">          datam))</span><br><span class=\"line\">      (begin</span><br><span class=\"line\">        (let* ([rtn (format &quot;did not find topic ~v~%&quot; topic-name)])</span><br><span class=\"line\">          (display rtn)</span><br><span class=\"line\">          rtn))))</span><br><span class=\"line\">        </span><br><span class=\"line\">(define (deque request)</span><br><span class=\"line\">  ; check if topic exists, remove 1st item from topic queue</span><br><span class=\"line\">  (let* ([js-hsh (request-&gt;jshash request)]</span><br><span class=\"line\">         [topic-name (hash-ref js-hsh &#x27;topicname)]</span><br><span class=\"line\">         [rtn (make-hash)]</span><br><span class=\"line\">         [datam (remove-data-from-topic topic-name)])</span><br><span class=\"line\">    (begin</span><br><span class=\"line\">      (hash-set! rtn &#x27;topic-name topic-name)</span><br><span class=\"line\">      (hash-set! rtn &#x27;payload datam)</span><br><span class=\"line\">      (displayln (format &quot;:datam:-&gt;~v --&gt; ~v~%&quot; datam rtn ))</span><br><span class=\"line\">      (displayln (with-output-to-string (lambda () (write-json rtn))))</span><br><span class=\"line\">      (http-response (with-output-to-string (lambda  () (write-json rtn)))))))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>The implementation of deque has 3 helper functions: “remove-data-from-topic”, “get-queue-for-topic” and “request-&gt;jshash”.</p>\n<ul>\n<li>Request-&gt;jshash takes the data coming in on the http POST and converts it to a Racket hash for easy access.</li>\n<li>get-queue-for-topic is a function to return the queue assoicated with a topic-name.</li>\n<li>remove-data-from-topic handles the actual removal of the top message from the topic queue.</li>\n<li>deque handles reformating the incoming http request, removing the data and formating the http response.</li>\n</ul>\n<h1 id=\"the-admin-interface\">The admin interface<a title=\"#the-admin-interface\" href=\"#the-admin-interface\"></a></h1>\n<p>Enque and deque are the “user interface” API calls for adding and removing messages to and from a topic. Next, let’s start on the administration interface. First we can implement “topic-list”, which simply creates a JSON list of all known topic names.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(define (topic-list request)</span><br><span class=\"line\">  ; show me all the topics in the topic-hash</span><br><span class=\"line\">  (begin</span><br><span class=\"line\">    (let* ([rtn (make-hash)])</span><br><span class=\"line\">      (hash-set! rtn &#x27;topic-list (hash-keys topic-hash))</span><br><span class=\"line\">           </span><br><span class=\"line\">      (displayln (with-output-to-string (lambda () (write-json rtn))))</span><br><span class=\"line\">      (http-response (with-output-to-string (lambda() (write-json rtn)))))))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>The implementation is straight forward. Create a return hash, which holds our topic name list. Get the current keys from the topic-name hash and format that list out as JSON.</p>\n<p>Let’s tackle “topic-count” and “topic-data”.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(define (topic-count request)</span><br><span class=\"line\">  ; show me a count of topics</span><br><span class=\"line\">  ; input: &#123; count-topics: &quot;all&quot; &#125;</span><br><span class=\"line\">  (begin</span><br><span class=\"line\">    (let ([rtn (make-hash)])</span><br><span class=\"line\">      (hash-set! rtn &#x27;topic-count (hash-count topic-hash))</span><br><span class=\"line\">      (displayln (with-output-to-string (lambda () (write-json rtn))))</span><br><span class=\"line\">      (http-response (with-output-to-string (lambda () (write-json rtn)))))))</span><br><span class=\"line\"></span><br><span class=\"line\">(define (topic-data request)</span><br><span class=\"line\">  ; list all data in a topic</span><br><span class=\"line\">  (let* ([hsh (request-&gt;jshash request)]</span><br><span class=\"line\">         [topic-name (hash-ref hsh &#x27;quename)]</span><br><span class=\"line\">         [rtn (make-hash)])</span><br><span class=\"line\">        (hash-set! rtn &#x27;topic-name topic-name)</span><br><span class=\"line\">        (hash-set!  rtn &#x27;topic-list (queue-&gt;list (hash-ref topic-hash topic-name)))</span><br><span class=\"line\">        (displayln (with-output-to-string (lambda () (write-json rtn))))</span><br><span class=\"line\">        (http-response (with-output-to-string (lambda () (write-json rtn))))))</span><br></pre></td></tr></table></figure>\n<p>The function “topic-count” grabs a count of the total number of topics in the topic hash at that moment and formats it out to a JSON object. The function “topic-data” returns a JSON list of all the messages associated with a topic.</p>\n<p>Next, we will code “drain-queue”. The function “drain-queue” is supposed to remove all data associated with an input topic-name. Danger!! The implementation takes advantage of the hash function library to overwrite the queue for that topic name with a freshly initialized and empty queue. That is, we OVERWRITE the old queue.  It is up to the gabage collector to free the memory used by the old messages in the old queue.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(define (drain-queue request)</span><br><span class=\"line\">  (let* ([hsh (request-&gt;jshash request)]</span><br><span class=\"line\">         [topic-name (hash-ref hsh &#x27;quename)]</span><br><span class=\"line\">         [rtn (make-hash)])</span><br><span class=\"line\">    (hash-set! topic-hash topic-name (make-queue))</span><br><span class=\"line\">    (hash-set!  rtn &#x27;topic-name topic-name)</span><br><span class=\"line\">    (hash-set! rtn &#x27;message &quot;drain-queue: all data deleted&quot;)</span><br><span class=\"line\">    (displayln (with-output-to-string (lambda () (write-json rtn))))</span><br><span class=\"line\">    (http-response (with-output-to-string (lambda ()  (write-json  rtn))))))</span><br></pre></td></tr></table></figure>\n<p>Finally, we can code “topic-remove”. This function removes the topic from the topic list. The Racket garbage collector will handle cleaning up the data/queue.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(define (topic-remove request)</span><br><span class=\"line\">  (let* ([hsh  (request-&gt;jshash request)]</span><br><span class=\"line\">         [topic-name (hash-ref hsh &#x27;quename)]</span><br><span class=\"line\">         [rtn (make-hash)])</span><br><span class=\"line\">    (hash-remove! topic-hash topic-name)</span><br><span class=\"line\">    (hash-set! rtn &#x27;message (format &quot;topic-remove: removed topic ~v&quot; topic-name))</span><br><span class=\"line\">    (displayln (with-output-to-string (lambda  () (write-json rtn))))</span><br><span class=\"line\">    (http-response (with-output-to-string (lambda () (write-json rtn))))))</span><br></pre></td></tr></table></figure>\n<p>With that we have defined a message queue. It is 218 lines total. It is not very sophisticaded. It also may have bugs.</p>\n<h1 id=\"conclusion\">Conclusion<a title=\"#conclusion\" href=\"#conclusion\"></a></h1>\n<p>That rounds out the full implementation of the message queue system. The next article will explore how to restrcuture the single code file so we can test it using Racket’s test capabilities.</p>\n","prev":{"title":"A-message-queue-in-racket-part-4","link":"2021/10/24/A-message-queue-in-racket-part-4"},"next":{"title":"A Message queue in Racket - part 2","link":"2021/10/22/A-message-queue-racket-part-2"},"plink":"http://muguira-james.github.io/2021/10/22/A-message-queue-in-racket-part-3/","toc":[{"id":"table-of-contents:","title":"Table of Contents:","index":"1"},{"id":"introduction","title":"Introduction","index":"2"},{"id":"implemention-of-dequeu---deleting-message-from-a-topic","title":"Implemention of dequeu - deleting message from a topic","index":"3"},{"id":"the-admin-interface","title":"The admin interface","index":"4"},{"id":"conclusion","title":"Conclusion","index":"5"}],"reading_time":"1786 words in 12 min"}